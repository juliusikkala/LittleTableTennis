#ifndef BOARD_HH
#define BOARD_HH
#include "object.hh"
#include "window.hh"
#include "resource_pool.hh"
#include "scene_graph.hh"
#include "scene.hh"
#include "camera.hh"
#include <vector>

class board
{
public:
    board(
        lt::window& win,
        lt::resource_pool& pool,
        const std::string& data_path,
        const std::string& board_path,
        const std::string& counter_path
    );

    lt::render_scene* get_scene();

    /* Sets the direction the paddle is moving in. player_index is the index of
     * the player whose paddle is moving, dir is the direction of the paddle:
     * dir > 0 => up
     * dir == 0 => not moving
     * dir < 0 => down
     */
    void set_paddle_dir(unsigned player_index, int dir);

    // Updates the board state
    void update(float dt);

    // Returns true and sets 'winner' to the index of the winning player if the
    // game is over. Otherwise returns false.
    bool declare_winner(unsigned& winner);

private:
    /* This object generally has the ownership of all the objects on the board.
     * In this case, the counter numbers form an exception, since they are
     * generated by the constructor.
     */
    lt::scene_graph graph;

    /* lt::render_scene should only contain stuff that should be rendered on the
     * next frame.
     */
    lt::render_scene scene;

    struct player
    {
        /* The number objects used to show the score. All players have
         * differently colored numbers, which is why the number objects are
         * player-specific.
         */
        struct {
            // Since the constructor creates custom models, they are stored here
            lt::model mod;
            lt::object obj;
        } numbers[10];
        // The paddle of the player
        lt::object* paddle;

        // The direction of the player's paddle
        int paddle_dir;

        // The score of the player
        unsigned score;
    };

    std::vector<player> players;
    lt::object* ball;

    lt::camera cam;
};

#endif
